#!/usr/bin/env python3
"""
Simple Column Extractor - Direct extraction for basic tasks like column mapping
"""

import json
import sys
import re
from typing import Dict, List, Any

def extract_columns_from_excel_text(content: str, file_name: str) -> List[Dict[str, Any]]:
    """
    Extract column names and worksheet names directly from Excel text representation
    """
    results = []
    
    if 'Excel file content' not in content:
        return results
    
    lines = content.split('\n')
    current_sheet = None
    
    for line in lines:
        line = line.strip()
        
        if line.startswith('=== Sheet:'):
            # Extract sheet name
            sheet_match = re.search(r'=== Sheet: (.+?) ===', line)
            if sheet_match:
                current_sheet = sheet_match.group(1).strip()
            continue
            
        elif current_sheet and line and not line.startswith('===') and not line.startswith('Row'):
            # This is likely a header row with column names
            # Split by tabs first (Excel format uses tabs between columns)
            columns = [col.strip() for col in line.split('\t') if col.strip()]
            
            # If no tabs found, fall back to splitting by multiple spaces
            if len(columns) <= 1:
                columns = [col.strip() for col in re.split(r'\s{2,}', line) if col.strip()]
            
            # Process each column (filter out row numbers and short strings)
            for column_name in columns:
                if (len(column_name) > 2 and 
                    not column_name.isdigit() and 
                    not re.match(r'^Row\s+\d+', column_name) and
                    not re.match(r'^\d{4}-\d{2}-\d{2}', column_name)):  # Skip date values
                    
                    results.append({
                        "column_name": column_name,
                        "worksheet_name": current_sheet,
                        "source_file": file_name
                    })
            
            # Only process first meaningful row per sheet for headers
            current_sheet = None
    
    return results

def simple_extraction_main(session_data: Dict[str, Any], start_index: int = 0, target_fields: List[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Main function for simple column extraction
    """
    
    all_columns = []
    
    # Process each file in the session
    for extracted_text in session_data.get('extractedTexts', []):
        content = extracted_text.get('content', '')
        file_name = extracted_text.get('fileName', 'Unknown')
        
        columns = extract_columns_from_excel_text(content, file_name)
        all_columns.extend(columns)
    
    # Create field validations using proper target field IDs
    field_validations = []
    
    # Get field mappings from target_fields if provided
    field_mapping = {}
    collection_name = "Column Name Mapping"
    
    if target_fields:
        for field in target_fields:
            field_name = field.get('propertyName') or field.get('fieldName', '')
            field_id = field.get('id', '')
            if field_id:
                if 'column' in field_name.lower() and 'heading' in field_name.lower():
                    field_mapping['column_heading'] = field_id
                elif 'worksheet' in field_name.lower() and 'name' in field_name.lower():
                    field_mapping['worksheet_name'] = field_id
                elif 'standardised' in field_name.lower() or 'standard' in field_name.lower():
                    field_mapping['standardised_column'] = field_id
                elif 'reasoning' in field_name.lower():
                    field_mapping['reasoning'] = field_id
                    
                # Get collection name from first field
                if not collection_name or collection_name == "Column Name Mapping":
                    collection_name = field.get('collectionName', 'Column Name Mapping')
    
    for i, column_data in enumerate(all_columns):
        record_index = start_index + i
        
        # Column Heading field
        if 'column_heading' in field_mapping:
            field_validations.append({
                "field_id": field_mapping['column_heading'],
                "validation_type": "collection_property",
                "data_type": "TEXT",
                "field_name": f"Column Heading[{record_index}]",
                "collection_name": collection_name,
                "extracted_value": f"{column_data['column_name']} ({column_data['worksheet_name']})",
                "confidence_score": 100,
                "validation_status": "verified",
                "ai_reasoning": f"Extracted directly from sheet '{column_data['worksheet_name']}' using column extraction",
                "record_index": record_index
            })
        
        # Worksheet Name field  
        if 'worksheet_name' in field_mapping:
            field_validations.append({
                "field_id": field_mapping['worksheet_name'],
                "validation_type": "collection_property", 
                "data_type": "TEXT",
                "field_name": f"Worksheet Name[{record_index}]",
                "collection_name": collection_name,
                "extracted_value": column_data['worksheet_name'],
                "confidence_score": 100,
                "validation_status": "verified",
                "ai_reasoning": f"Extracted worksheet name for column '{column_data['column_name']}'",
                "record_index": record_index
            })
    
    return {
        "success": True,
        "message": f"Simple extraction completed: {len(all_columns)} columns extracted",
        "field_validations": field_validations,
        "extraction_method": "simple_direct",
        "processing_time_ms": 10,  # Much faster than AI
        "columns_found": len(all_columns)
    }

if __name__ == "__main__":
    if len(sys.argv) > 1:
        # Read session data from stdin
        session_input = sys.stdin.read()
        try:
            session_data = json.loads(session_input)
            start_index = int(sys.argv[1]) if len(sys.argv) > 1 else 0
            
            result = simple_extraction_main(session_data, start_index)
            print(json.dumps(result))
        except Exception as e:
            print(json.dumps({
                "success": False,
                "error": f"Simple extraction failed: {str(e)}",
                "extraction_method": "simple_direct"
            }))
    else:
        print("Usage: python3 simple_column_extractor.py <start_index>")